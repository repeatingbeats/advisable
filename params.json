{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"advisable.js","body":"# advisable.js\r\n\r\n__advisable.js__ is an implementation of functional mixins for synchronous and asynchronous before/after/around aspect-oriented advice. It is heavily inspired by a [talk on functional mixins](https://speakerdeck.com/u/anguscroll/p/how-we-learned-to-stop-worrying-and-love-javascript) by [Dan Webb](https://twitter.com/danwrong) and [Angus Croll](https://twitter.com/angustweets) at [FluentConf 2012](http://fluentconf.com/fluent2012).\r\n\r\nThis is certainly not the first JS implementation of advice, nor even the first implementation derived from patterns presented in the FluentConf talk. The goals and motivations behind reinventing this particular wheel are:\r\n\r\n* Adherence to Node.js idioms (sync/async method separation, synchronous versions of methods appended with `Sync`, callbacks take errors as the first argument by convention).\r\n\r\n* Clear, consistent calling semantics for declaring whether or not advice mutates arguments and return values.\r\n\r\n* Thorough testing. This library injects intermediary methods into call chains and is intended to be used widely to modularize code in applications. As such, extensive testing of all expected use cases is a requirement.\r\n\r\n## Supported Environments\r\n\r\n__advisable.js__ is tested in a Node.js environment and supports CommonJS or AMD before falling back to adding an `advisable` property on the global object. The library should work in any browser environment with no dependencies provided that either a native or shimmed implementation of `Function.prototype.bind` is available. Browser support is caveated with *should* as tests are not currently run in browsers.\r\n\r\n## Usage\r\n\r\nThe following usage examples are, quite obviously, contrived to show advice usage with simple arithmetic. In all examples, the object mixing in advisable methods is referred to as the target object, and the method receiving advice is the target method. All examples can be found and executed in [examples/advisable.js](https://github.com/repeatingbeats/advisable/blob/master/examples/advisable.js)\r\n\r\nThe `mutate` option allows advice callers to declare whether or not advice mutates arguments and return values. `mutate` defaults to false and the options object may be omitted entirely. Note that this option specifically refers to argument/return value mutation, as advice methods are invoked in the context of the target object, which is mutable within all advice methods.\r\n\r\nadvisable's around advice is a syntactic shortcut for advising a target with both before and after advise in a single method call. This isi unlike some other implementations, which pass the target function to a wrapper and expect the wrapper to invoke the target.\r\n\r\nFirst, we set up a very simple object with sync and async methods to advise:\r\n\r\n    function Target(val) {\r\n      this.val = val;\r\n    }\r\n\r\n    Target.prototype.syncFunc = function (a, b) {\r\n      return a + b + this.val;\r\n    };\r\n\r\n    Target.prototype.asyncFunc = function (a, b, callback) {\r\n      process.nextTick(function () {\r\n        callback(null, a + b + this.val);\r\n      }.bind(this));\r\n    };\r\n\r\nAdvice methods are mixed in to a target object by invoking the functional mixin with the target object context.\r\n\r\n    // Sync/async advice is mixed in separately\r\n    advisable.sync.call(Target.prototype);\r\n    advisable.async.call(Target.prototype);\r\n\r\n### Synchronous Usage\r\n\r\nFirst, without advice:\r\n\r\n    target = new Target(1);\r\n\r\n    // 10 + 100 + 1 => 111\r\n    target.syncFunc(10, 100));\r\n\r\nBefore advice that changes target object state:\r\n\r\n    target = new Target(1);\r\n    target.beforeSync('syncFunc', function (a, b) {\r\n      this.val++;\r\n    });\r\n\r\n    // 10 + 100 + 2 => 112\r\n    target.syncFunc(10, 100);\r\n\r\nBefore advice that mutates arguments:\r\n\r\n    target = new Target(1);\r\n    target.beforeSync('syncFunc', function (a, b) {\r\n      return [ a/10, b/10 ];\r\n    }, { mutate: true });\r\n\r\n    // 10/10 + 100/10 + 1 => 12\r\n    target.syncFunc(10, 100);\r\n\r\nAfter advice that changes target state but does not mutate return value:\r\n\r\n    target = new Target(1);\r\n    target.afterSync('syncFunc', function (a, b) {\r\n      this.val--;\r\n    });\r\n\r\n    // 10 + 100 + 1 => 111 (original return value)\r\n    target.syncFunc(10, 100));\r\n\r\n    // But target.val is now 0 due to decrementing after advice\r\n\r\nAfter advice that mutates a return value:\r\n\r\n    target = new Target(1);\r\n    target.afterSync('syncFunc', function (v) {\r\n      return v * 2;\r\n    }, { mutate: true });\r\n\r\n    // (10/10 + 100/10 + 1) * 2 => 222\r\n    target.syncFunc(10, 100);\r\n\r\nAround advice that simply observes:\r\n\r\n    target = new Target(1);\r\n    target.aroundSync(\r\n      'syncFunc'\r\n    , function (a, b) {\r\n        console.log('around:before called with args: %d, %d', a, b);\r\n      }\r\n    , function (a, b) {\r\n        console.log('around:after called with args: %d, %d', a, b);\r\n      }\r\n    );\r\n\r\n    // 10 + 100 + 1 => 111\r\n    target.syncFunc(10, 100);\r\n\r\nAround advice that mutates arguments and return value:\r\n\r\n    target = new Target(1);\r\n    target.aroundSync(\r\n      'syncFunc'\r\n    , function (a, b) {\r\n        return [ a * 3, b * 3 ];\r\n      }\r\n    , function (v) {\r\n        return v + 123;\r\n      }\r\n    , { mutate: true }\r\n    );\r\n\r\n    // ((10*3) + (100*3) + 1) + 123 => 454\r\n    target.syncFunc(10, 100);\r\n\r\n### Asynchronous Usage\r\n\r\nFirst, without advice:\r\n\r\n    target = new Target(1);\r\n\r\n    target.asyncFunc(10, 100, function (err, result) {\r\n      // result = 10 + 100 + 1 => 111\r\n    });\r\n\r\nBefore advice that changes target object state:\r\n\r\n    target = new Target(1);\r\n    target.before('asyncFunc', function (a, b, callback) {\r\n      this.val++;\r\n      // Non-mutated async advice must call back, but the error (first) argument\r\n      // is the only argument considered.\r\n      callback();\r\n    });\r\n\r\n    target.asyncFunc(10, 100, function (err, result) {\r\n      // result = 10 + 100 + 2 => 112\r\n    });\r\n\r\nBefore advice that mutates arguments:\r\n\r\n    target = new Target(1);\r\n    target.before('asyncFunc', function (a, b, callback) {\r\n      callback(null, a/10, b/10);\r\n    }, { mutate: true });\r\n\r\n    target.asyncFunc(10, 100, function (err, result) {\r\n      // result = 10/10 + 100/10 + 1 => 12\r\n    });\r\n\r\nAfter advice that changes target object state:\r\n\r\n    target = new Target(1);\r\n    target.after('asyncFunc', function (a, b, callback) {\r\n      this.val--;\r\n      callback();\r\n    });\r\n\r\n    target.asyncFunc(10, 100, function (err, result) {\r\n      // result = 10 + 100 + 1 => 111 (original return value)\r\n      // target.val is now 0 (assuming, of course, that no one else changed it)\r\n    });\r\n\r\nAfter advice that mutates the return value:\r\n\r\n    target = new Target(1);\r\n    target.after('asyncFunc', function (v, callback) {\r\n      callback(null, v * 2);\r\n    }, { mutate: true });\r\n\r\n    target.asyncFunc(10, 100, function (err, result) {\r\n      // result = (10/10 + 100/10 + 1) * 2 => 222\r\n    });\r\n\r\nAround advice that simply observes:\r\n\r\n    target = new Target(1);\r\n    target.around(\r\n      'asyncFunc'\r\n    , function (a, b, callback) {\r\n        console.log('around:before called with args: %d, %d', a, b);\r\n        callback();\r\n      }\r\n    , function (a, b, callback) {\r\n        console.log('around:after called with args: %d, %d', a, b);\r\n        callback();\r\n      }\r\n    );\r\n\r\n    target.asyncFunc(10, 100, function (err, result) {\r\n      // result = 10 + 100 + 1 => 111\r\n    });\r\n\r\nAround advice that mutates arguments and return value:\r\n\r\n    target = new Target(1);\r\n    target.around(\r\n      'asyncFunc'\r\n    , function (a, b, callback) {\r\n        callback(null, a * 3, b * 3);\r\n      }\r\n    , function (v, callback) {\r\n        callback(null, v + 123);\r\n      }\r\n    , { mutate: true }\r\n    );\r\n\r\n    target.asyncFunc(10, 100, function (err, result) {\r\n      // result = ((10*3) + (100*3) + 1) + 123 => 454\r\n    });\r\n\r\n## API\r\n\r\nFor now, see inline documentation in [advisable.js](https://github.com/repeatingbeats/advisable/blob/master/lib/advisable.js)\r\n\r\n## Testing\r\n\r\n    $ make test\r\n\r\n## Linting\r\n\r\n    $ make lint\r\n\r\n## License\r\n\r\nadvisable.js is MIT licensed. See [LICENSE](https://github.com/repeatingbeats/advisable/blob/master/LICENSE).\r\n","google":"","tagline":"Functional JS mixins for sync and async aspect-oriented advice"}